package svc

import (
	"context"
	"errors"
	"fmt"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"io"
	"log/slog"
	"net/http"
	"strings"
	"time"
	"yodleeops/internal/infra"
	openapi "yodleeops/openapi/sources"
)

const ApiUrl = "/yodlee-ops/api/v1"
const FrontendDistDir = "./frontend/dist"

func RootMiddleware(allowedOrigins string, next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		trace := r.Header.Get("X-trace")
		if trace == "" {
			trace = uuid.NewString()
		}
		r = r.WithContext(context.WithValue(r.Context(), "trace", trace))

		w.Header().Set("Access-Control-Allow-Origin", allowedOrigins)
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-trace")
		w.Header().Set("Access-Control-Allow-Credentials", "true")

		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusNoContent)
			return
		}
		next.ServeHTTP(w, r)
	})
}

func MakeRoot(app *App, allowOrigins string) http.Handler {
	mux := http.NewServeMux()

	oGenServer, err := openapi.NewServer(&FiOpsAPIHandler{App: app}, &FiOpsSecurityHandler{App: app})
	if err != nil {
		panic(fmt.Sprintf("failed to make root: %v", err))
	}

	// ogen generated api: a trailing slash is needed for prefix matching. strip prefix allows ogen to do exact path matching.
	mux.Handle(ApiUrl+"/", http.StripPrefix(ApiUrl, RootMiddleware(allowOrigins, oGenServer)))

	// streaming api: cannot be generated by ogen.
	mux.Handle(ApiUrl+"/events/taillog", RootMiddleware(allowOrigins, http.HandlerFunc(app.StreamFiObjectLogs)))

	// dedicated swagger-ui page: served from the openapi static directory.
	mux.Handle("/swagger-ui", http.StripPrefix("/swagger-ui", http.FileServer(http.Dir("./openapi/static"))))

	return mux
}

func (app *App) AuthorizeToken(ctx context.Context, token string) (context.Context, error) {
	// todo: implement token validation here. in this implementation, Authorization allows all users.
	return ctx, nil
}

type FiOpsSecurityHandler struct {
	*App
}

func (h *FiOpsSecurityHandler) HandleBearerAuth(ctx context.Context, _ openapi.OperationName, t openapi.BearerAuth) (context.Context, error) {
	return h.AuthorizeToken(ctx, t.Token)
}

func FFormatEvent(w io.Writer, topic string, msg string) {
	fmt.Fprintf(w, "event: %s\ndata: %s\n\n", topic, msg)
}

func (app *App) StreamFiObjectLogs(w http.ResponseWriter, r *http.Request) {
	authorization := r.Header.Get("Authorization")
	ctx, err := app.AuthorizeToken(r.Context(), authorization)
	if err != nil {
		http.Error(w, "access denied", http.StatusUnauthorized)
		return
	}

	values := r.URL.Query()
	profileIDs := strings.Split(values.Get("prefix"), ",")
	subjects := strings.Split(values.Get("subjects"), ",")

	var topics []infra.Topic
	for _, subject := range subjects {
		switch openapi.FiSubject(subject) {
		case openapi.FiSubjectConnections:
			topics = append(topics, infra.CnctRefreshTopic, infra.CnctResponseTopic)
		case openapi.FiSubjectAccounts:
			topics = append(topics, infra.AcctRefreshTopic, infra.AcctResponseTopic)
		case openapi.FiSubjectTransactions:
			topics = append(topics, infra.TxnRefreshTopic, infra.TxnResponseTopic)
		case openapi.FiSubjectHoldings:
			topics = append(topics, infra.HoldRefreshTopic, infra.HoldResponseTopic)
		}
	}

	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	slog.InfoContext(ctx, "begin log tail streaming", "subjects", subjects, "topics", topics, "prefix", profileIDs)

	f, ok := w.(http.Flusher)
	if !ok {
		http.Error(w, "streaming unsupported", http.StatusMethodNotAllowed)
		return
	}

	FFormatEvent(w, "meta", "init")
	f.Flush()

	subChan := app.FiMessageBroadcaster.Subscribe(SubscriberFilter{Topics: topics, ProfileIDs: profileIDs})

	go func() {
		defer app.FiMessageBroadcaster.Unsubscribe(subChan)
		<-ctx.Done()
	}()

	ticker := time.NewTicker(15 * time.Second)
	for {
		select {
		case msg, ok := <-subChan:
			if !ok {
				return
			}
			FFormatEvent(w, "log", msg)
		case <-ticker.C:
			FFormatEvent(w, "meta", "ping")
		}
		f.Flush()
	}
}

func BucketFromSubject(buckets infra.S3Buckets, subject openapi.FiSubject) infra.Bucket {
	var bucket infra.Bucket
	switch subject {
	case openapi.FiSubjectConnections:
		bucket = buckets.CnctBucket
	case openapi.FiSubjectAccounts:
		bucket = buckets.AcctBucket
	case openapi.FiSubjectTransactions:
		bucket = buckets.TxnBucket
	case openapi.FiSubjectHoldings:
		bucket = buckets.HoldBucket
	default:
		bucket = buckets.CnctBucket
	}
	return bucket
}

func mapOpsFiMetadata(opsFiMetadata []OpsFiMetadata, subject openapi.FiSubject) []openapi.OpsFiMetadata {
	opsFiMetadataResp := make([]openapi.OpsFiMetadata, 0)
	for _, metadata := range opsFiMetadata {
		opsFiMetadataResp = append(opsFiMetadataResp, openapi.OpsFiMetadata{
			Subject:           subject,
			Key:               metadata.Key,
			LastModified:      metadata.LastModified,
			ProfileID:         metadata.ProfileID,
			ProviderAccountID: metadata.ProviderAccountID,
			PartyIDTypeCd:     metadata.PartyIDTypeCd,
			AccountID:         metadata.AccountID,
			ElementID:         metadata.ElementID,
			LastUpdated:       metadata.LastUpdated,
		})
	}
	return opsFiMetadataResp
}

type FiOpsAPIHandler struct {
	*App
}

var _ openapi.Handler = (*FiOpsAPIHandler)(nil)

const InternalServerErrorMessage = "internal server error"

func (h *FiOpsAPIHandler) GetFiMetadataByPrefix(ctx context.Context, params openapi.GetFiMetadataByPrefixParams) (openapi.GetFiMetadataByPrefixRes, error) {
	appCtx := AppContext{Context: ctx, App: h.App}

	internalServerError := func(err error) *openapi.GetFiMetadataByPrefixInternalServerError {
		slog.ErrorContext(ctx, "failed to list fi metadata by prefix", "err", err, "params", params)
		return &openapi.GetFiMetadataByPrefixInternalServerError{ErrorCode: openapi.ErrorCodeFATALERROR, ErrorDesc: InternalServerErrorMessage}
	}

	bucket := BucketFromSubject(h.S3Buckets, params.Subject)

	opsFiMetadata, nextCursor, err := ListFiMetadataByPrefix(appCtx, bucket, params.Prefix, params.Cursor.Value)
	if err != nil {
		return internalServerError(err), nil
	}

	return &openapi.ListFiMetadataResponse{
		OpsFiMetadata: mapOpsFiMetadata(opsFiMetadata, params.Subject),
		Cursor:        nextCursor,
	}, nil
}

func (h *FiOpsAPIHandler) GetFiMetadataByProfiles(ctx context.Context, params openapi.GetFiMetadataByProfilesParams) (openapi.GetFiMetadataByProfilesRes, error) {
	appCtx := AppContext{Context: ctx, App: h.App}

	internalServerError := func(err error) *openapi.GetFiMetadataByProfilesInternalServerError {
		slog.ErrorContext(ctx, "failed to list fi metadata by profiles", "err", err, "params", params)
		return &openapi.GetFiMetadataByProfilesInternalServerError{ErrorCode: openapi.ErrorCodeFATALERROR, ErrorDesc: InternalServerErrorMessage}
	}

	profileIDs := strings.Split(params.ProfileIDs, ",")
	bucket := BucketFromSubject(h.S3Buckets, params.Subject)

	var arrayCursor []string
	if params.Cursor == "" {
		// default: the first cursor is an empty ContinuationToken for each profileID
		arrayCursor = MakeFirstCursor(len(profileIDs))
	} else {
		arrayCursor = strings.Split(params.Cursor, ",")
	}

	if len(profileIDs) != len(arrayCursor) {
		return &openapi.GetFiMetadataByProfilesBadRequest{
			ErrorCode: openapi.ErrorCodePROFILEIDCURSORLENGTH,
			ErrorDesc: "prefix and cursor must be the same length",
		}, nil
	}
	var pairs []ListFiMetadataQuery
	for i, profileID := range profileIDs {
		pairs = append(pairs, ListFiMetadataQuery{ProfileID: profileID, ContinuationToken: arrayCursor[i]})
	}

	fiMetadataResults, err := ListFiMetadataByProfileIDs(appCtx, bucket, pairs)
	if err != nil {
		return internalServerError(err), nil
	}

	return &openapi.ListFiMetadataResponse{
		OpsFiMetadata: mapOpsFiMetadata(fiMetadataResults.OpsFiMetadata, params.Subject),
		Cursor:        fiMetadataResults.Cursor,
	}, nil
}

func (h *FiOpsAPIHandler) GetFiObject(ctx context.Context, params openapi.GetFiObjectParams) (openapi.GetFiObjectRes, error) {
	appCtx := AppContext{Context: ctx, App: h.App}

	internalServerError := func(err error) *openapi.GetFiObjectInternalServerError {
		slog.ErrorContext(ctx, "failed to get fi object", "err", err)
		return &openapi.GetFiObjectInternalServerError{ErrorCode: openapi.ErrorCodeFATALERROR, ErrorDesc: InternalServerErrorMessage}
	}

	keyInput := params.Key
	bucketInput := BucketFromSubject(h.S3Buckets, params.Subject)

	opsFiObject, err := GetFiObject(appCtx, bucketInput, keyInput)
	if errors.Is(err, ErrKeyNotFound) {
		return &openapi.GetFiObjectNotFound{
			ErrorCode: openapi.ErrorCodeKEYNOTFOUND,
			ErrorDesc: err.Error(),
		}, nil
	} else if err != nil {
		return internalServerError(err), nil
	}
	slog.InfoContext(appCtx, "retrieved fi message object", "key", keyInput, "bucket", bucketInput)

	fiObjectData := make(map[string]jx.Raw)
	for k, v := range opsFiObject.Data {
		fiObjectData[k] = jx.Raw(v)
	}

	return &openapi.FiObject{
		ProfileId:   opsFiObject.ProfileId,
		Timestamp:   opsFiObject.Timestamp,
		OriginTopic: string(opsFiObject.OriginTopic),
		Data:        fiObjectData,
	}, nil
}
