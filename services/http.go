package svc

import (
	"context"
	"errors"
	"fmt"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"io"
	"log/slog"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
	"yodleeops/internal/infra"
	openapi "yodleeops/openapi/sources"
)

const ApiUrl = "/yodlee-ops/api/v1"
const FrontendDistDir = "./frontend/dist"

func RootMiddleware(allowedOrigins string, next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		trace := r.Header.Get("X-trace")
		if trace == "" {
			trace = uuid.NewString()
		}
		r = r.WithContext(context.WithValue(r.Context(), "trace", trace))

		w.Header().Set("Access-Control-Allow-Origin", allowedOrigins)
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-trace")
		w.Header().Set("Access-Control-Allow-Credentials", "true")

		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusNoContent)
			return
		}
		next.ServeHTTP(w, r)
	})
}

func MakeRoot(app *App, allowOrigins string) http.Handler {
	mux := http.NewServeMux()

	oGenServer, err := openapi.NewServer(&FiObjectHandler{App: app})
	if err != nil {
		panic(fmt.Sprintf("failed to make root: %v", err))
	}

	// ogen generated api: a trailing slash is needed for prefix matching. strip prefix allows ogen to do exact path matching.
	mux.Handle(ApiUrl+"/", http.StripPrefix(ApiUrl, RootMiddleware(allowOrigins, oGenServer)))

	// streaming api: cannot be generated by ogen.
	mux.Handle(ApiUrl+"/events/taillog", RootMiddleware(allowOrigins, http.HandlerFunc(app.StreamFiObjectLogs)))

	// dedicated swagger-ui page: served from the openapi static directory.
	mux.Handle("/swagger-ui", http.StripPrefix("/swagger-ui", http.FileServer(http.Dir("./openapi/static"))))

	// react ui page: served from the frontend dist directory.
	fs := http.FileServer(http.Dir(FrontendDistDir))
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		info, err := os.Stat(filepath.Join(FrontendDistDir, r.URL.Path))
		fileExists := err == nil && !info.IsDir()
		if fileExists {
			fs.ServeHTTP(w, r)
		} else {
			// allows defaulting to index page if the file requested does not exist.
			http.ServeFile(w, r, filepath.Join(FrontendDistDir, "index.html"))
		}
	})

	return mux
}

func FFormatEvent(w io.Writer, topic string, msg string) {
	fmt.Fprintf(w, "event: %s\ndata: %s\n\n", topic, msg)
}

func (app *App) StreamFiObjectLogs(w http.ResponseWriter, r *http.Request) {
	filterQuery := func(elements []string) []string {
		for i, element := range elements {
			if element == "" {
				elements = append(elements[:i], elements[i+1:]...)
			}
		}
		return elements
	}

	values := r.URL.Query()
	profileIDs := filterQuery(strings.Split(values.Get("profileIDs"), ","))
	subjects := filterQuery(strings.Split(values.Get("subjects"), ","))

	var topics []infra.Topic
	for _, subject := range subjects {
		switch openapi.FiSubject(subject) {
		case openapi.FiSubjectConnections:
			topics = append(topics, infra.CnctRefreshTopic, infra.CnctResponseTopic)
		case openapi.FiSubjectAccounts:
			topics = append(topics, infra.AcctRefreshTopic, infra.AcctResponseTopic)
		case openapi.FiSubjectTransactions:
			topics = append(topics, infra.TxnRefreshTopic, infra.TxnResponseTopic)
		case openapi.FiSubjectHoldings:
			topics = append(topics, infra.HoldRefreshTopic, infra.HoldResponseTopic)
		}
	}

	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	slog.InfoContext(r.Context(), "begin log tail streaming", "subjects", subjects, "topics", topics, "profileIDs", profileIDs)

	f, ok := w.(http.Flusher)
	if !ok {
		http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
		return
	}

	FFormatEvent(w, "meta", "init")
	f.Flush()

	subChan := app.FiMessageBroadcaster.Subscribe(SubscriberFilter{Topics: topics, ProfileIDs: profileIDs})

	go func() {
		defer app.FiMessageBroadcaster.Unsubscribe(subChan)
		<-r.Context().Done()
	}()

	ticker := time.NewTicker(15 * time.Second)
	for {
		select {
		case msg, ok := <-subChan:
			if !ok {
				return
			}
			FFormatEvent(w, "log", msg)
		case <-ticker.C:
			FFormatEvent(w, "meta", "ping")
		}
		f.Flush()
	}
}

func BucketFromSubject(buckets infra.S3Buckets, subject openapi.FiSubject) infra.Bucket {
	var bucket infra.Bucket
	switch subject {
	case openapi.FiSubjectConnections:
		bucket = buckets.CnctBucket
	case openapi.FiSubjectAccounts:
		bucket = buckets.AcctBucket
	case openapi.FiSubjectTransactions:
		bucket = buckets.TxnBucket
	case openapi.FiSubjectHoldings:
		bucket = buckets.HoldBucket
	default:
		bucket = buckets.CnctBucket
	}
	return bucket
}

type FiObjectHandler struct {
	*App
}

var _ openapi.Handler = (*FiObjectHandler)(nil)

const InternalServerErrorMessage = "internal server error"

func (h *FiObjectHandler) GetFiMetadata(ctx context.Context, params openapi.GetFiMetadataParams) (openapi.GetFiMetadataRes, error) {
	appCtx := AppContext{Context: ctx, App: h.App}

	internalServerError := func(err error) *openapi.GetFiMetadataInternalServerError {
		slog.ErrorContext(ctx, "failed to list fi metadata", "err", err)
		return &openapi.GetFiMetadataInternalServerError{ErrorCode: openapi.ErrorCodeFATALERROR, ErrorDesc: InternalServerErrorMessage}
	}

	profileIDs := strings.Split(params.ProfileIDs, ",")
	var arrayCursor []string
	if params.Cursor == "" {
		// default: the first cursor is a non-ContinuationToken for each profileID
		arrayCursor = MakeFirstCursor(len(profileIDs))
	} else {
		arrayCursor = strings.Split(params.Cursor, ",")
	}
	bucket := BucketFromSubject(h.S3Buckets, params.Subject)

	if len(profileIDs) != len(arrayCursor) {
		return &openapi.GetFiMetadataBadRequest{
			ErrorCode: openapi.ErrorCodePROFILEIDCURSORLENGTH,
			ErrorDesc: "profileIDs and cursor must be the same length",
		}, nil
	}
	var pairs []ListFiMetadataQuery
	for i, profileID := range profileIDs {
		pairs = append(pairs, ListFiMetadataQuery{ProfileID: profileID, ContinuationToken: arrayCursor[i]})
	}

	fiMetadataResults, err := ListFiMetadataByProfileIDs(appCtx, bucket, pairs)
	if err != nil {
		return internalServerError(err), nil
	}

	opsFiMetadata := make([]openapi.OpsFiMetadata, 0)
	for _, metadata := range fiMetadataResults.OpsFiMetadata {
		opsFiMetadata = append(opsFiMetadata, openapi.OpsFiMetadata(metadata))
	}

	return &openapi.ListFiMetadataResponse{
		OpsFiMetadata: opsFiMetadata,
		Cursor:        fiMetadataResults.Cursor,
	}, nil
}

func (h *FiObjectHandler) GetFiObject(ctx context.Context, params openapi.GetFiObjectParams) (openapi.GetFiObjectRes, error) {
	appCtx := AppContext{Context: ctx, App: h.App}

	internalServerError := func(err error) *openapi.GetFiObjectInternalServerError {
		slog.ErrorContext(ctx, "failed to get fi object", "err", err)
		return &openapi.GetFiObjectInternalServerError{ErrorCode: openapi.ErrorCodeFATALERROR, ErrorDesc: InternalServerErrorMessage}
	}

	keyInput := params.Key
	bucketInput := BucketFromSubject(h.S3Buckets, params.Subject)

	opsFiObject, err := GetFiObject(appCtx, bucketInput, keyInput)
	if errors.Is(err, ErrKeyNotFound) {
		return &openapi.GetFiObjectNotFound{
			ErrorCode: openapi.ErrorCodeKEYNOTFOUND,
			ErrorDesc: err.Error(),
		}, nil
	} else if err != nil {
		return internalServerError(err), nil
	}
	slog.InfoContext(appCtx, "retrieved fi message object", "key", keyInput, "bucket", bucketInput)

	fiObjectData := make(map[string]jx.Raw)
	for k, v := range opsFiObject.Data {
		fiObjectData[k] = jx.Raw(v)
	}

	return &openapi.FiObject{
		ProfileId:   opsFiObject.ProfileId,
		Timestamp:   opsFiObject.Timestamp,
		OriginTopic: string(opsFiObject.OriginTopic),
		Data:        fiObjectData,
	}, nil
}
